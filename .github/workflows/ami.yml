name: AMI Update

on:
  workflow_dispatch:
  schedule:
    - cron: '0 6 * * *'
  push:
    branches:
      - '*'  # This will trigger for pushes to any branch

jobs:
  compare-ami:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        env: [sit, uat, ops]

    name: Compare AMI for ${{ matrix.env }}

    steps:

      - name: Set environment variables
        run: |
          echo "UPPERCASE=${{ matrix.env }}" >> $GITHUB_ENV
          echo "lowercase=$(echo "${{ matrix.env }}" | tr '[:upper:]' '[:lower:]')" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets[format('AWS_ACCESS_KEY_ID_SERVICES_{0}', env.UPPERCASE)] }}
          aws-secret-access-key: ${{ secrets[format('AWS_SECRET_ACCESS_KEY_SERVICES_{0}', env.UPPERCASE)] }}
          aws-region: us-west-2  # change this if needed

      - name: Get deployed AMI ID
        id: deployed
        run: |
          TAG_NAME="${{ env.lowercase }}-hitide-backfill-tool-CumulusECSCluster"
          DEPLOYED_AMI=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=$TAG_NAME" \
            --query "Reservations[].Instances[].ImageId" \
            --output text | tr '\t' '\n' | sort | uniq)
          echo "Deployed AMI for $TAG_NAME: $DEPLOYED_AMI"
          echo "ami_id=$DEPLOYED_AMI" >> "$GITHUB_OUTPUT"

      - name: Get SSM AMI ID
        id: ssm
        run: |
          SSM_PARAM="/ngap/amis/image_id_ecs_al2023_x86"
          PARAM_AMI=$(aws ssm get-parameter \
            --name "$SSM_PARAM" \
            --with-decryption \
            --query "Parameter.Value" \
            --output text)
          echo "SSM AMI for $SSM_PARAM: $PARAM_AMI"
          echo "ami_id=$PARAM_AMI" >> "$GITHUB_OUTPUT"

      - name: Compare AMI IDs
        id: compare
        run: |
          DEPLOYED="${{ steps.deployed.outputs.ami_id }}"
          EXPECTED="${{ steps.ssm.outputs.ami_id }}"

          echo "Comparing for ${{ matrix.env }}:"
          echo "Deployed: $DEPLOYED"
          echo "Expected: $EXPECTED"

          if [ "$DEPLOYED" != "$EXPECTED" ]; then
            echo "❌ AMI Mismatch in ${{ matrix.env }}!"
            echo "mismatch=true" >> $GITHUB_OUTPUT
          else
            echo "✅ AMI Match for ${{ matrix.env }}!"
            echo "mismatch=false" >> $GITHUB_OUTPUT
          fi


      - name: Initial checkout
        if: steps.compare.outputs.mismatch == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # This ensures we get all branches

      - name: Set branch name
        id: set-branch
        if: steps.compare.outputs.mismatch == 'true'
        run: |
          if [ "${{ matrix.env }}" = "sit" ]; then
            echo "branch=develop" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.env }}" = "ops" ]; then
            echo "branch=main" >> $GITHUB_OUTPUT
          elif [ "${{ matrix.env }}" = "uat" ]; then
            # Fetch all branches to ensure we have latest release branches
            git fetch --all
            # Check for release branches and get the latest one
            if git ls-remote --heads origin 'release/*' | grep .; then
              LATEST_RELEASE=$(git ls-remote --heads origin 'release/*' | sort -t '/' -k 3 -V | tail -n 1 | awk '{print $2}' | sed 's/refs\/heads\///')
              echo "Found release branch: $LATEST_RELEASE"
              echo "branch=$LATEST_RELEASE" >> $GITHUB_OUTPUT
            else
              echo "No release branch found, using main"
              echo "branch=main" >> $GITHUB_OUTPUT
            fi
          else
            echo "❌ Invalid environment: ${{ matrix.env }}"
            exit 1
          fi
          echo "Selected branch for ${{ matrix.env }}: $(cat $GITHUB_OUTPUT | grep branch | cut -d'=' -f2)"

      - name: Checkout appropriate branch
        if: steps.compare.outputs.mismatch == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.set-branch.outputs.branch }}


